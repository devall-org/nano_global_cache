defmodule NanoGlobalCacheTest do
  use ExUnit.Case
  doctest NanoGlobalCache

  defmodule TokenCache do
    use NanoGlobalCache

    cache :github do
      fetch fn ->
        send(Agent.get(:cur_test, & &1), :github)
        token = "gho_#{:rand.uniform(10000)}"
        expires_at = System.system_time(:millisecond) + 200
        {:ok, token, expires_at}
      end
    end

    cache :google do
      fetch fn ->
        send(Agent.get(:cur_test, & &1), :google)
        :error
      end
    end

    cache :slack do
      fetch fn ->
        send(Agent.get(:cur_test, & &1), :slack)
        token = "xoxb_#{:rand.uniform(10000)}"
        expires_at = System.system_time(:millisecond) + :timer.hours(1)
        {:ok, token, expires_at}
      end
    end

    # fetch/1 is auto-generated by the transformer
  end

  setup do
    this = self()
    Agent.start_link(fn -> this end, name: :cur_test)

    on_exit(fn ->
      TokenCache.clear_all()
      # Ensure all :pg groups are cleaned up
      for cache_name <- [:github, :google, :slack] do
        group = {TokenCache, cache_name}

        :pg.get_members(:nano_global_cache, group)
        |> Enum.each(fn pid ->
          try do
            Agent.stop(pid)
          catch
            _, _ -> :ok
          end
        end)
      end
    end)

    :ok
  end

  describe "fetch/1" do
    test "caches GitHub tokens until expiration" do
      now = System.system_time(:millisecond)
      {:ok, token1, expires_at1} = TokenCache.fetch(:github)
      assert_receive :github
      assert is_integer(expires_at1)
      assert expires_at1 > now

      {:ok, token2, expires_at2} = TokenCache.fetch(:github)
      # cached, no re-execution (no external API call)
      refute_receive :github
      assert token1 == token2
      assert expires_at1 == expires_at2

      Process.sleep(300)

      {:ok, token3, expires_at3} = TokenCache.fetch(:github)
      assert_receive :github
      assert token3 != token1
      assert expires_at3 > expires_at1
    end

    test "does not cache Google token refresh failures" do
      :error = TokenCache.fetch(:google)
      assert_receive :google

      :error = TokenCache.fetch(:google)
      # refresh failures are retried on each call
      assert_receive :google
    end
  end

  describe "fetch!/1" do
    test "returns GitHub token on success" do
      token = TokenCache.fetch!(:github)
      assert_receive :github
      assert String.starts_with?(token, "gho_")
    end

    test "raises on Google token refresh failure" do
      assert_raise RuntimeError, fn -> TokenCache.fetch!(:google) end
      assert_receive :google
    end
  end

  describe "clear" do
    test "removes cache before expiration" do
      {:ok, token1, _} = TokenCache.fetch(:github)
      {:ok, token2, _} = TokenCache.fetch(:github)
      assert token1 == token2

      TokenCache.clear(:github)

      {:ok, token3, _} = TokenCache.fetch(:github)
      assert token3 != token1
    end

    test "clear_all removes all caches" do
      {:ok, token1, _} = TokenCache.fetch(:github)
      :error = TokenCache.fetch(:google)

      TokenCache.clear_all()

      {:ok, token2, _} = TokenCache.fetch(:github)
      assert token2 != token1
    end
  end

  describe "supervision" do
    test "agents are added to DynamicSupervisor" do
      # Initially no children
      %{active: active_before} = DynamicSupervisor.count_children(NanoGlobalCache.Supervisor)

      # Create first cache
      {:ok, _, _} = TokenCache.fetch(:github)
      %{active: active_after_1} = DynamicSupervisor.count_children(NanoGlobalCache.Supervisor)
      assert active_after_1 == active_before + 1

      # Create second cache
      {:ok, _, _} = TokenCache.fetch(:slack)
      %{active: active_after_2} = DynamicSupervisor.count_children(NanoGlobalCache.Supervisor)
      assert active_after_2 == active_before + 2

      # Clear one cache
      TokenCache.clear(:github)
      %{active: active_after_clear} = DynamicSupervisor.count_children(NanoGlobalCache.Supervisor)
      assert active_after_clear == active_before + 1
    end

    test "agents are added to :pg groups" do
      group_github = {TokenCache, :github}
      group_slack = {TokenCache, :slack}

      # Initially no members
      assert :pg.get_members(:nano_global_cache, group_github) == []
      assert :pg.get_members(:nano_global_cache, group_slack) == []

      # Create first cache
      {:ok, _, _} = TokenCache.fetch(:github)
      assert length(:pg.get_members(:nano_global_cache, group_github)) == 1

      # Create second cache
      {:ok, _, _} = TokenCache.fetch(:slack)
      assert length(:pg.get_members(:nano_global_cache, group_slack)) == 1

      # Clear removes from pg
      TokenCache.clear(:github)
      assert :pg.get_members(:nano_global_cache, group_github) == []
      assert length(:pg.get_members(:nano_global_cache, group_slack)) == 1
    end

    test "local members are preferred" do
      group = {TokenCache, :github}

      # First fetch creates local member
      {:ok, token1, expires_at1} = TokenCache.fetch(:github)

      # Verify local member exists
      [_local_pid] = :pg.get_local_members(:nano_global_cache, group)

      # Second fetch should use the same local member (no fetch call)
      {:ok, token2, expires_at2} = TokenCache.fetch(:github)
      assert token1 == token2
      assert expires_at1 == expires_at2
      assert_receive :github, 100

      # No additional fetch messages (meaning it used cache)
      refute_receive :github
    end
  end
end
