defmodule NanoGlobalCacheTest do
  use ExUnit.Case
  doctest NanoGlobalCache

  defmodule TokenCache do
    use NanoGlobalCache

    cache :github do
      expires_in 200

      fetch fn ->
        send(Agent.get(:cur_test, & &1), :github)
        {:ok, "gho_#{:rand.uniform(10000)}"}
      end
    end

    cache :google do
      expires_in 200

      fetch fn ->
        send(Agent.get(:cur_test, & &1), :google)
        :error
      end
    end

    # fetch/1 is auto-generated by the transformer
  end

  setup do
    this = self()
    Agent.start_link(fn -> this end, name: :cur_test)
    on_exit(fn -> TokenCache.clear_all() end)
    :ok
  end

  test "caches GitHub tokens until expiration" do
    refute_receive :github
    {:ok, token1} = TokenCache.fetch(:github)
    assert_receive :github

    {:ok, token2} = TokenCache.fetch(:github)
    # cached, no re-execution (no external API call)
    refute_receive :github
    assert token1 == token2

    Process.sleep(300)

    refute_receive :github
    {:ok, token3} = TokenCache.fetch(:github)
    assert_receive :github
    assert token3 != token1
  end

  test "does not cache Google token refresh failures" do
    refute_receive :google
    :error = TokenCache.fetch(:google)
    assert_receive :google

    :error = TokenCache.fetch(:google)
    # refresh failures are retried on each call
    assert_receive :google
  end

  test "fetch! returns GitHub token on success" do
    refute_receive :github
    token = TokenCache.fetch!(:github)
    assert_receive :github

    assert is_binary(token)
    assert String.starts_with?(token, "gho_")
  end

  test "fetch! raises on Google token refresh failure" do
    refute_receive :google
    assert_raise RuntimeError, fn -> TokenCache.fetch!(:google) end
    assert_receive :google
  end
end
